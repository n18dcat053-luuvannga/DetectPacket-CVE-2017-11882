import pyshark, csv, sys, os, binascii, hashlib
from datetime import datetime
import subprocess
import os
import array
from pathlib import Path
import socket
import tqdm
# import subprocess
def get_protocal(pck):
	highProtocal = ""
	try:
		data = pck.frame_info.protocols.split(":")
		protocol = str(data.pop())
		if protocol == 'data':
			highProtocal = 'data'
			protocol = str(data.pop())
	except Exception as e:
		return "",highProtocal
	return  protocol,highProtocal

def get_info(pck):
	try:
		protocol,highProtocal = get_protocal(pck)
		if highProtocal == 'data':
			pck_all_field = pck.DATA
			string = str(pck_all_field.data)
			#string = str(pck[highProtocal].data)
		else:
			data = str(pck[protocol]).replace('\n','|')
			data = data.replace('\t',' ')
			data = data.replace('\r','')
			string = data[data.find('|')+1:]
	except Exception as e:
		return " "
	return string


def get_info1(pck):
	string = ""
	try:
		protocol, _ = get_protocal(pck)
		if "tcp" in pck:
			if "tcp.payload" in pck.tcp._all_fields:
				string = pck.tcp.payload.replace(':', '')
				# if "25504446" in string:
				# 	print("payload:", string)
				return string

		data = str(pck[protocol]).replace('\n', '|')
		data = data.replace('\t', ' ')
		data = data.replace('\r', '')
		string = data[data.find('|') + 1:]
	except Exception as e:
		print(e)
		return " "
	return string

def convertPcapToCsv():
	try:
		capture = pyshark.FileCapture('temp1.pcap')
		capture.load_packets()
		fieldnames = ['No', 'Timestamp', 'Source','Destination','Protocal','length','info']

		with open('temp1.csv', 'w') as csv_file:
			writer = csv.writer(csv_file, delimiter=',',lineterminator='\n')
			writer.writerow(fieldnames)
			for item in capture:
				if 'IP' in item:
					protocol,highProtocal = get_protocal(item)
					length = item.length
					writer.writerow([item.number,item.sniff_timestamp,item.ip.src,item.ip.dst,protocol,length,get_info1(item)])
				if 'IPV6' in item:
					protocol,highProtocal = get_protocal(item)
					length = item.length
					writer.writerow([item.number,item.sniff_timestamp,item.ipv6.src,item.ipv6.dst,protocol,length,get_info1(item)])
		# print('--Convert Successful!')
		time = datetime.now().strftime('%d-%m-%Y-%H_%M_%S')
		#check size file
		if (os.path.getsize("temp1.csv")//1000) >= 1:
			os.system('copy temp.csv packet\\'+time+'.csv')
		capture.close()
	except Exception as ecsv:
		capture.close()
		print("Convert unsuccess!! - ",ecsv)

def detectRemoteCode():
	rowsSampleDetect = []
	with open('sample-detect.csv','r') as csvsample:
		detectReader = csv.reader(csvsample)
		detectField = next(detectReader)
		for row in detectReader:
			#col 0 ->md5; col 1 ->ProgramName; col 2->Detail
			rowsSampleDetect.append(row)
	with open('temp1.csv', 'r') as csvfile:
		csvreader = csv.reader(csvfile)
		fields = next(csvreader)
		for row in csvreader:
			if row[4]=='tcp' and row[6].find("|")<0 and int(row[5])>1024:
				#col 0 ->No; col 1 ->Timestamp; col 2 ->sr; col 3 ->dst; 
				#col 4 ->Protocal; col 5 ->length; col 6 ->info
				# print(row[6][:100])
				# data1=row[6][:100].encode('utf-8')
				# print(data1)
				# print(hashlib.md5(data1).hexdigest())
				data = str(row[6][:2048].encode('utf-8'))
				#payload = "4d5a4152554889e54883ec204883e4f0e8000000005b4881c3ff5a0000ffd34881c3ecae020048893b4989d86a045affd000"
				# print(data)
				# print(hashlib.md5(data).hexdigest())
				# print(row[0])
				for rowdt in rowsSampleDetect:
					if rowdt[0] in data:
						time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
						string = time+" [Warning] sr IP:"+row[2]+" remote code to dst IP:"+row[3] \
						+" [md5:"+rowdt[0]+"|process:"+rowdt[1]+"|Detail:"+rowdt[2]+"]"
						print(string,"\n")
						#Write Log
						with open('log.txt', 'a') as log:
							log.write(string)
							log.write("\n")
	#Run continuously
# if not os.path.isdir("packet\\"):
# 	os.system('mkdir packet')
# while True:
# 	try:
# 		print('-- Restart Capture --')
# 		captureLive = pyshark.LiveCapture(interface='VMware Network Adapter VMnet8',output_file='temp1.pcap')
# 		captureLive.sniff(timeout=40) #capture on 40 seconds
# 		captureLive.close()
# 	except KeyboardInterrupt as er:
# 		print('Interrupt By [Ctr + C] -> exit program')
# 		captureLive.close()
# 		sys.exit()
# 		os.system('cls')
# 	#Run convert file Pcap to CSV
# 	convertPcapToCsv()
# 	time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
# 	detectRemoteCode()
# 	#Check Detect attack
# 	try:
# 		print(time,' - Check Remote Code Execution Vulnerability')
# 		detectRemoteCode()
# 	except Exception as e:
# 		print('Error: ',e)
def getTCPPayload(packet):
	if 'tcp' in packet:
		if 'tcp.payload' in packet.tcp._all_fields:
			a=str(packet.tcp.payload)
			tcpPayload = a.replace(':','')
			data = bytes.fromhex(tcpPayload)

			# return data.decode('utf-8', 'replace').encode('cp850','replace').decode('cp850')\
			# 	.replace('\n','').replace('\t','')\
			# 	.replace('\r','').replace('\\x', '')\
			# 	.replace(',', '|')
			return data.decode('utf-8', 'replace').encode('cp850','replace').decode('cp850')\
				.replace('\n','').replace('\t','')\
				.replace('\r','').replace('\\x', '')\
				.replace(',', '|')
	return ''

def get_packet_details(packet):

	protocol = packet.transport_layer
	source_address = packet.ip.src
	source_port = packet[packet.transport_layer].srcport
	destination_address = packet.ip.dst
	destination_port = packet[packet.transport_layer].dstport
	packet_time = packet.sniff_time
	packet_data = str(getTCPPayload(packet)).encode('utf-8')
	f = open('result-traffic.csv', 'a')
	writer = csv.writer(f, delimiter=',',lineterminator='\n')
	row = [protocol, source_address, source_port, destination_address, destination_port, packet_time, packet_data]
	writer.writerow(row)
	return {
		"protocol":protocol, 
		"source_address":source_address, 
		"source_port":source_port, 
		"destination_address":destination_address, 
		"destination_port":destination_port, 
		"packet_time":packet_time, 
		"packet_data":packet_data
	}

def capture_live_packets(network_interface):
	capture = pyshark.LiveCapture(interface=network_interface, display_filter="tcp")
	for raw_packet in capture.sniff_continuously():
		p = get_packet_details(raw_packet)
		if isAttackPacket(p):
			time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
			string = time+" [Warning] sr IP:"+p['source_address']+" remote code to dst IP:"+p['destination_address']\
			+" CVE_2019_8464 DETECTED"
			print(string,"\n")
			#Write Log
			with open('log.txt', 'a') as log:
				log.write(string)
				log.write("\n")

def isAttackPacket(p):
	if p['packet_data'] is None:
		return False
	data = str(p['packet_data'])
	if "MZARUH" and "This program cannot be run in DOS mode" in data:
		return True
	return False
def server():
	SERVER_HOST = "192.168.1.5"    
	SERVER_PORT = 1235
	# receive 4096 bytes each time
	BUFFER_SIZE = 4096
	SEPARATOR = "<SEPARATOR>"
	s = socket.socket()
	s.bind(('192.168.1.5', SERVER_PORT))
	s.listen(5)
	print(f"[*] Listening as 192.168.1.5:{SERVER_PORT}")
	client_socket, address = s.accept() 
	print(f"[+] {address} is connected.")
	received = client_socket.recv(BUFFER_SIZE).decode()
	filename, filesize = received.split(SEPARATOR)
	filename = os.path.basename(filename)
	filesize = int(filesize)
	filename1= filename
	progress = tqdm.tqdm(range(filesize), f"Receiving {filename}", unit="B", unit_scale=True, unit_divisor=1024)
	with open(filename, "wb") as f:
		while True:
			bytes_read = client_socket.recv(BUFFER_SIZE)
			if not bytes_read:    
				break
			f.write(bytes_read)
			progress.update(len(bytes_read))
	client_socket.close()
	s.close()
	filename1 = "data.txt"
	if os.path.isfile(filename1):
		print("\nCo file: "+ filename1)
	with open(filename1) as f:
		if "File LNK PAYLOAD" in f.read():
			print("CO FILE LNK LAYLOAD")
			return True
	return False

print('-- Restart Capture --')
try:
	capture_live_packets('VMware Network Adapter VMnet8')
except Exception as e:
	print(e)